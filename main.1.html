<html>
<head>
  <meta charset="utf-8">
  <title>Project</title>
  <script src="lib/jquery-1.9.1.min.js"></script>
  <script type="text/javascript" src="lib/purl.js"></script>
  <script type="text/javascript" src="lib/jasmine-1.3.1/jasmine.js"></script>
  <script type="text/javascript" src="lib/jasmine-1.3.1/jasmine-html.js"></script>

  <!-- include source files here... -->
  <script type="text/javascript" src="src/OPS.js"></script>
  <script type="text/javascript" src="src/ConceptWikiSearch.js"></script>
  <script type="text/javascript" src="src/CompoundSearch.js"></script>
  <script type="text/javascript" src="src/TargetSearch.js"></script>
  <script type="text/javascript" src="src/ConceptWikiSearch.js"></script>
  <script type="text/javascript" src="src/StructureSearch.js"></script>
  <script type="text/javascript" src="src/TreeSearch.js"></script>
  <script type="text/javascript" src="src/ActivitySearch.js"></script>
  <script type="text/javascript" src="src/PathwaySearch.js"></script>
  <script type="text/javascript" src="src/MapSearch.js"></script>
  <script type="text/javascript" src="src/DataSources.js"></script>
  <script type="text/javascript" src="src/DiseaseSearch.js"></script>
  <script type="text/javascript" src="src/Version.js"></script>  
  
  <link rel="stylesheet" href="css/style.css" media="screen" type="text/css" />
  <!-- setup -->
  <script type="text/javascript">
var prmstr = window.location.search.substr(1);
var prmarr = prmstr.split ("&");
var params = {};

for ( var i = 0; i < prmarr.length; i++) {
    var tmparr = prmarr[i].split("=");
    params[tmparr[0]] = tmparr[1];
}
var jsonData = {};
  </script>

</head>

<body>
	<div id="tfheader">
		<form id="tfnewsearch" method="get" action="main.1.html">
		        <input type="text" class="tftextinput" name="search" size="21" maxlength="120"><input type="submit" value="Search a Disease" class="tfbutton">
		</form>
	<div class="tfclear"></div>
	</div>
	<h3>Pathways reverse to targets</h3>
  <p><div id="TargetsofPathway">Nothing yet</div></p>
  <h3>Pathways</h3>
  <p><div id="pathway">Nothing yet</div></p>
  <h3>Target</h3>
  <p><div id="target">Nothing yet</div></p>
  <h3>Link</h3>
  <p><div id="link">Nothing yet</div></p>
  <h3>Jsoncheck</h3>
  <p><div id="json">Nothing yet</div></p>
  <!-- <h3>JSON reply</h3>
  <p><div id="json">Nothing yet</div></p> -->
  <script type="text/javascript">
var searcher = new Openphacts.ConceptWikiSearch("https://beta.openphacts.org/1.4","319894f5", "6992b9c544389ddda346cbb4cec5c6ec");  
var diseaseUrl;
var treeMaker = 0;
var getDiseaseUrl = function(success, status, response){
  //document.getElementById("link").innerHTML = "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
  dataJSON = JSON.stringify(response);
  data = JSON.parse(unescape(dataJSON));
  document.getElementById("link").innerHTML = "<a href=\"" + data.primaryTopic.result._about + "\">" + data.primaryTopic.result._about + "</a>";
  diseaseUrl = data.primaryTopic.result._about;
  var searcher = new Openphacts.DiseaseSearch("https://beta.openphacts.org/1.4","319894f5", "6992b9c544389ddda346cbb4cec5c6ec"); 
  searcher.targetsByDisease(diseaseUrl, null, null, null, null, getTargets);
};




var getTargets=function(success, status, response){
if (status == 200) {
	jsonData.children = [];
	//document.getElementById("target").innerHTML = "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
	dataJSON = JSON.stringify(response);
	data = JSON.parse(unescape(dataJSON));
	document.getElementById("target").innerHTML = "	";
	var searcher = new Openphacts.PathwaySearch("https://beta.openphacts.org/1.3","319894f5", "6992b9c544389ddda346cbb4cec5c6ec"); 
	for (var i=0; i<data.items.length; i++) {
	  var nameTarget = data.items[i].seeAlso[1].prefLabel_en;
	  if (nameTarget == undefined) 
	  nameTarget = data.items[i].seeAlso[2].prefLabel_en;
	  document.getElementById("target").innerHTML += "<br> <a href=\"" + data.items[i]._about + "\">" + nameTarget + "</a> </br>";
	  searcher.byTarget(data.items[i]._about, null, null, null, null, null, getPathways);
	}
	}
};


var getPathways = function(success, status, response){
  if (status == 200) {
    //document.getElementById("pathway").innerHTML += "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
    dataJSON = JSON.stringify(response);
    data = JSON.parse(unescape(dataJSON));
	//console.log("item0: " + data.items[0]);
	document.getElementById("pathway").innerHTML += "<br><b>" + data.items[0].hasPart.exactMatch.prefLabel_en + "</b></br>";
	for (var i=0; i<data.items.length; i++) {

	  var checking = 0;
	  for (var j=0; j<jsonData.children.length; j++){
		if (jsonData.children[j].name == data.items[i].title){
			checking = 1;
		}
	  }
	if(checking == 0){
	  jsonData.children.push({"name" : data.items[i].title_en});
	
	  document.getElementById("pathway").innerHTML += "<br> <a href=\"" + data.items[i].identifier + "\">" + data.items[i].title +"</br>";
	  var searcher = new Openphacts.PathwaySearch("https://beta.openphacts.org/1.3","319894f5", "6992b9c544389ddda346cbb4cec5c6ec");
	  searcher.getTargets(data.items[i].identifier, null, getTargetsofPathways);
	  document.getElementById("json").innerHTML += "<br><b>" + jsonData.children[i].name + "</b></br>";
	 
	}
	}
	
	


  }
}

var getTargetsofPathways = function(success, status, response){
if (status == 200) {
	dataJSON = JSON.stringify(response);
	data = JSON.parse(unescape(dataJSON));
	
	//document.getElementById("TargetsofPathway").innerHTML += "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
	

	var index;
	for(var j = 0; j<jsonData.children.length ; j++){
		if (jsonData.children[j].name == data.primaryTopic.latest_version.title_en){
			index = j;
			break;
			}
	}
	//console.log(index);
	//document.getElementById("TargetsofPathway").innerHTML += "<br><b>" + data.primaryTopic.latest_version.title_en + "</b></br>";
	var searcher = new Openphacts.DiseaseSearch("https://beta.openphacts.org/1.4","319894f5", "6992b9c544389ddda346cbb4cec5c6ec");
	jsonData.children[index].pathfather = [];
	for (var i=0; i<data.primaryTopic.latest_version.hasPart.length; i++) {
	jsonData.children[index].pathfather.push({"father": data.primaryTopic.latest_version.hasPart[i]});
	searcher.diseasesByTarget(data.primaryTopic.latest_version.hasPart[i], null, null, null, null, diseaseFromTarget);
	//document.getElementById("TargetsofPathway").innerHTML += "<br> <a href=\"" + data.primaryTopic.latest_version.hasPart[i] + "\">" + data.primaryTopic.latest_version.hasPart[i] +"</br>";
	}
	}
}

var diseaseFromTarget = function(success, status, response){
	if (status == 200) {
	/*
	
	*/
//document.getElementById("TargetsofPathway").innerHTML += "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
		dataJSON = JSON.stringify(response);
		data = JSON.parse(unescape(dataJSON));
		
		//document.getElementById("TargetsofPathway").innerHTML += "<pre>" + JSON.stringify(response, null, '  ') + "</pre>";
		//document.getElementById("TargetsofPathway").innerHTML += data.items[1].name;

		
		fatherLink = data.isPartOf._about.split("https://beta.openphacts.org/1.4/disease/byTarget?_format=json&app_key=6992b9c544389ddda346cbb4cec5c6ec&app_id=319894f5&uri=");
		//document.getElementById("TargetsofPathway").innerHTML += "<br>" +fatherLink[1]+ "</br>"
		var indexD = null;
		for(var j = 0; j<jsonData.children.length ; j++){
			for(var k = 0; k<jsonData.children[j].pathfather.length ; k++){
				if (jsonData.children[j].pathfather[k].father == fatherLink[1]){
				indexD = j;
				break;
				}
			}
			if (indexD != null){
				break;
			}
	}
	console.log(indexD);
	jsonData.children[indexD].children = [];
	
		for (var i=0; i<data.items.length; i++) {
			jsonData.children[indexD].children.push({"name": data.items[i].name});
			//document.getElementById("TargetsofPathway").innerHTML += "<br>" + data.items[i].name + "</br>"
		}
		root = jsonData;
		update(jsonData);
	}
}
jsonData.name = params ['search'];	
searcher.byTag(params ['search'], '1', '1', 'eda73945-b112-407e-811a-88448966834f', getDiseaseUrl);


  </script>
  <!-- D3 collipsable tree -->
 
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var margin = {top: 20, right: 120, bottom: 20, left: 120},
    width = 960 - margin.right - margin.left,
    height = 800 - margin.top - margin.bottom;
    
var i = 0,
    duration = 750,
    root;

var tree = d3.layout.tree()
    .size([height, width]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
/*	
var treeData = [
  {
    "name": "Top Level",
    "parent": "null",
    "children": [
      {
        "name": "Level 2: A",
        "parent": "Top Level",
        "children": [
          {
            "name": "Son of A",
            "parent": "Level 2: A"
          },
          {
            "name": "Daughter of A",
            "parent": "Level 2: A"
          }
        ]
      },
      {
        "name": "Level 2: B",
        "parent": "Top Level"
      }
    ]
  }
];
*/
/*
d3.json( "flare.json", function(flare) {
  root = flare;
  root.x0 = height / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root);
});
*/

d3.select(self.frameElement).style("height", "800px");

function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodesâ€¦
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", click);

  nodeEnter.append("circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 4.5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the linksâ€¦
  var link = svg.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}

</script>
</body>
</html>
